# -*- coding: utf-8 -*-
"""aulasModulo2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pIlyBOjOneWCPAYgMT0OsSN9YXmHdz3E
"""

# Trabalhando com 'array' utilizando a biblioteca 'numpy'
import numpy as np # 'as np' é o apelido dado a biblioteca
import pandas as pd

help(np.pi)

df

# Descrição de como utilizar:
help(np.array)

# Criação array 1D (UMA DIMENSÃO):
lista = [1, 2, 3]
x = np.array(lista) # cria o 'array' jogando na variável 'x'
print(f'Valor de x:\n {x}')
print(f'Shape: {x.shape}') # Mostra a quantidade de elementos dentro do 'array'

# Verifica o tipo da variável 'x', nesse caso retorna 'numpy.ndarray'
type(x)

# Criando um 'array 2D (DUAS DIMENSÕES):
lista =[[1,2], [3,4]]
x2d = np.array(lista) # Poderia jogar os dados da lista direto dentro do array
print(f'Valor de x2d:\n {x2d}')
print(f'Shape: {x2d.shape}')

# Criando um 'array' com apenas '0':
val = (2,2) # Nesse caso representa 2 linhas e 2 colunas usando o 'np.zero'
x0 = np.zeros(val)
print(f'O valor de x:\n {x0}')
print(f'Shape: {x0.shape}')

# Criando um 'array' com apenas '1':
val = (2,2) # Linhas e Colunas
x1 = np.ones(val)
print(f'Valor de x1:\n {x1}')
print(f'Shape: {x1.shape}')

# Criando valores dentro de um intervalo com 'array', usando 'linspace'
x_min, x_max = 5, 15
x = np.linspace(start=x_min, stop=x_max, num=6) # 'linsspace' deixa os espaços entre os itens pontuados.
print(f'Valor de x:\n {x}')
print(f'Shape: {x.shape}')

# Criando uma matriz identidade
n = 4
x = np.eye(n)
print(f'Valor de x:\n {x}') # Usando o 'eye' cria uma matriz com '1' na diagonal e '0' nos demais
print(f'Shape: {x.shape}')

# Gerando valores aleatórios com 'array':
x = np.random.random(size=(2,3)) # Cria numeros aleatorios entre 0 e 1
print(f'Valores de x:\n {x}')
print(f'Shape: {x.shape}')

# Acessando um 'array' com 'Indexação' simples:
lista = [88, 19, 46, 74, 94]
x = np.array(lista)
print(f'O valor de x na posição 3 é: {x[3]}')

# Acessando um 'array' com 'Slicing' (Retorna um subarray):
lista = [[88, 19, 46, 74, 94], [69, 79, 26, 7, 29],
        [21, 45, 12, 80, 72], [28, 53, 65, 26, 64], 
        [71, 96, 34, 61, 52]]
B = np.array(lista)
print(f'Resultado com Slicing:\n {B[1:3, 1:4]}') 

#Saída [79,26,7]
#      [45,12,80]

# Indexação usando 'linspace':
x = np.linspace(start=10, stop=100, num=10)
print(f'Valor de x:\n {x}')
print(f'Shape: {x.shape}')
print(f'Primeiro elemento: {x[0]}')
print(f'Segundo elemento: {x[1]}')
print(f'Último elemento: {x[9]}')
print(f'Último elemento também: {x[-1]}')

# Extração de subarray com 'Slicing':
print(f'Valor de x:\n {x}')
print(f'Dois primeiros elementos: {x[0:2]}')
print(f'Dois primeiros elementos também: {x[:2]}')
print(f'Dois ultimos elementos: {x[-2:]}')
print(f'Dois ultimos elementos tambem: {x[8:]}')

# 'Slicing' com 'reshap':
x = x.reshape(2, 5) # Nesse caso cria um novo 'array' com 2 linhas e 5 colunas
print(f'Valor de x:\n {x}')

# Compartilhamento de memoria com alteração nas duas variáveis:
x = np.array([1,2,3])
print(f'Valor de x ANTES: {x}')
y = x[:] # Recebe todos os valores de 'x'
y[0] = -100 # Altera o primeiro elemento para '-100', PORÉM ALTERA 'x' também
print(f'Valor de x DEPOIS: {x}')
print(f'Valor de y: {y}')

# Compartilhamento de memoria evitando alteração da variável principal:
x = np.array([1,2,3])
print(f'Valor de x ANTES: {x}')
y = x[:].copy() # Recebe todos os valores de 'x', mantendo 'x' inalterado 'copy()' é essencial para manter os valores de 'x'
y[0] = -100 # Altera o primeiro elemento para '-100', PORÉM ALTERA 'x' também
print(f'Valor de x DEPOIS: {x}')
print(f'Valor de y: {y}')

# Operações Aritméticas com 'numpy array':
x = np.ones((2, 2)) # Cria um 'array' só com números '1'
y = np.eye(2) # Cria um 'array' com diagonal principal só com '1'
print(f'Valor de x:\n {x}')
print(f'Valor de y:\n {y}')

# Somando elemento a elemento:
print(f'Soma de x, y:\n {x + y}') # Soma o valor de x[0] com y[0] e assim sucessivamente

# Somando através do 'broadcasting'
print(f'Soma de x float ou int:\n {x + 2}') # Soma o valor declarado '2' a todos os valores do 'array x'

# Subtração elemento a elemento:
print(f'Subtraindo x, y:\n {x - y}') # Subtrai o valor de x[0] com y[0] e assim sucessivamente

# Subtração através do 'broadcasting':
print(f'Subtração de x float ou int:\n {x - 2}') # Nesse caso subtrai o valor declarado '2' a todos os valores do 'array x'

# Divisão elemento a elemento:
print(f'A divisão de x, y:\n {x / y}') # Nesse caso retorna um 'inf' porque 'y' tem '0', erro reportado 'RuntimeWarning: divide by zero encountered in true_divide'

# Divisão de x através do 'broadcasting':
print(f'A divisão de x float ou int:\n {x / 2}')

# Usando mais de uma operação ao mesmo tempo:
print(f'A combinação de operações:\n {(x + y) / (x - 2)}')

# Quando o 'broadcasting' não funciona:
np.array([1,2,3]) + np.array([1,2]) # Nesse caso terá erro(ValueError) porque o 'array' não reconhecerá o '3' no primeiro 'array'

# Operações Matriciais:
x = np.ones((2, 2)) # Necessário os dois '()'
y = np.eye(2)
print(f'Valor de x:\n {x}')
print(f'Valor de y:\n {y}')

# Multiplicando elemento a elemento:
print(f'Multilicando x, y:\n {x * y}')

# Multiplicando usando 'broadcasting':
print(f'Multiplicando x:\n {x * 2}')

# Multiplicação Matricial (As três operações mostra o mesmo resultado):
print(f'Multiplicando matricial com [np.dot]:\n {np.dot(x, y)}')
print(f'Multiplicando matricial com [@]:\n {x @ y}')
print(f'Multiplicando matricial com [.dot]\n {x.dot(y)}')

# Sistema de Equação com 'array':
"""
Exemplo:
Sistema de equações:
1a + 2b = 7
3 * a - 2b = -11
solução análitica: (a, b) = (-1, 4) Espera esse resultado
Matricialmente este problema tem a seguinte forma:
Ax = c, onde:
 x = [a, b]
 A = [[1,2], [3, -2]]
 c = [7, -11]
solução númerica: x = inv(A) @ c
"""

# Definição do problema
A = np.array([[1,2], [3, -2]]) # 'Array' de '1a, 2b, 3*a e -2b'
c = np.array([[7], [-11]]) # 'Array' de '7, -11'
print(f'Valor de A:\n {A}')
print(f'Valor de c:\n {c}')

# Solução do Problema:
#x = np.dot(np.linalg.inv(A), c) # 'linalg.inv' faz a inversa da matriz multiplicando por 'c'
x = np.linalg.inv(A) @ c # Também poderia ser reescrita assim
print(f'O valor de a, b: {x.ravel()}') # 'ravel' retorna o 'array' dentro de uma lista só.

# Comparações com 'numpy array':

x = np.array([[1, 2], [3, 4]])
y = np.array([1.5, 3.5])
print(f'Valor de x:\n {x}')
print(f'Valor de y:\n {y}')

# Comparações ponto a ponto:
print(f'Comparação de um array com um escalar (>):\n {x > 2}')
print(f'Comparação de um array com um esclar (>=):\n {x >= 2}')
print(f'Comparação de um array com um escalar (<):\n {x < 2}')
print(f'Comparação de um array com um escalar (<=):\n {x <= 2}')
print(f'Comparações entre array (==):\n {x == x}') # Retorna sempre 'true'
print(f'Comparações entre array (>):\n {x > x}') # Retorna sempre 'false'
print(f'Comaparações entre array (>):\n {x > y}') # Usando 'broadcasting'

# Indexação Booleana:
x = np.array([[1, 3, 7],
              [4, 11, 21],
              [42, 8, 9]])
print(f'Valor de x:\n {x}')

# Verificando uma condição:

k = 10
cond = x > k
print(f'Condição:\n {cond}')
print(f'Elementos maiores que {k}: {x[cond]}') # Verifica os números maiores na variável 'cond'
print(f'Número de elementos maiores que {k}: {len(x[cond])}') # Conta os números maiores na variável 'cond'

# Extração dos números PARES:
cond = x % 2 == 0
print(f'Condição:\n {cond}')
print(f'Números Pares: {x[cond]}')

# Extração dos números IMPARES:
cond = x % 2 != 0
print(f'Condição:\n {cond}')
print(f'Números Impares: {x[cond]}')

# Outras operações úteis com numpy:
x = np.array([[1, 3, 7],
              [4, 11, 21],
              [42, 8, 9]])
print(f'Valor de x:\n {x}')

# Usando o 'reshape' para transformar o 'array' em uma coluna:
print(f'Transformando em um array coluna:\n {x.reshape(9,1)}') # array coluna (obs: o número dos elementos declarado deve ser iguais a qtd do array original)
print(f'Transformando em um array em linha:\n {x.reshape(1, 9)}') # array linha 

# Transposição de Matriz (Linha vira coluna e vice-versa):
print(f'Transpondo Matriz x:\n {x.T}') # 'T' faz a transposição

# 'np.sum': Soma em um dado eixo, axis = (0: linha, 1: coluna)
print(f'Valor de x:\n {x}') # Mostra o 'array' x
print(f'Soma todos elementos de x: {np.sum(x)}')
print(f'Soma ao longo das linhas de x: {np.sum(x, axis=0)}') # 'axis=0' refere-se as linhas do array [1, 4, 42] e assim sucessivamente
print(f'Soma ao longo das colunas de x: {np.sum(x, axis=1)}') # 'axis=1' refere-se as colunas do array [1, 3, 7] e assim sucessivamente

# 'np.mean': média em um dado eixo, axis = (0: linha, 1: coluna)
print(f'Valor de x:\n {x}') # Mostra o 'array' x
print(f'Média todos elementos de x: {np.mean(x)}') # 'mean' Calcula a média
print(f'Média ao longo das linhas de x: {np.mean(x, axis=0)}') # 'axis=0' refere-se as linhas do array [1, 4, 42] e assim sucessivamente
print(f'Média ao longo das colunas de x: {np.mean(x, axis=1)}') # 'axis=1' refere-se as colunas do array [1, 3, 7] e assim sucessivamente

# 'np.where' identificação de indices
cond = x % 2 == 0 # Verifica os Pares
print(f'Condição:\n {cond}')
i, j = np.where(cond) # Retorna os indices usando x[i, j] ou x[cond] retorna os mesmos valores
print(f'Indices i (linhas True): {i}') # Nesse caso os True é: [4, 42, 8] posição [1,2,2]
print(f'Indices j (colunas True): {j}') # Nesse caso os True é: [4, 42, 8] posição [0,0,1]

# Verificando as linhas que possuem números pares:
i_row = np.where(np.sum(cond, axis=1))[0] # Retorna os indices das linhas que tem algum número par
print(f'Indice das linhas com Pares: {i_row}')
print(f'Linhas que possuem números Pares:\n {x[i_row, :]}') # Mostra um array das linhas que possuem pares

# Regressão Linear (descreve um comportamento de um volume de dados):

# Biblioteca para visualização de dados:
import matplotlib.pyplot as plt

# Dados:
x = [-1., -0.77777778, -0.55555556, -0.33333333, -0.11111111,
      0.11111111, 0.33333333, 0.55555556, 0.77777778, 1.]
y = [-1.13956201, -0.57177999, -0.21697033, 0.5425699, 0.49406657,
     1.14972239, 1.64228553, 2.1749824, 2.64773614, 2.95684202]

# Plot dos dados:
plt.figure(figsize=(10,5)) # Define o tamanho da figura
plt.plot(x, y, 'o', label='dados originais') # Faz o 'plot' o 'o' define o grafico com bolinhas.
plt.legend() # Expõe o label dados originais
plt.xlabel("x") # Define os nomes dos eixos
plt.ylabel("y")
plt.grid() # quadricular a figura
plt.show()

# Solução via minimização do erro quadrático usando a pseudo-inversa de X:
"""
Estimando a função do tipo y = a*x +b
Achando os valores de a e b que melhor 
representa o dado.
Valores reais de (a, b): 2, 1
"""

# Transformando para 'numpy' e vetor coluna:
x, y = np.array(x).reshape(-1, 1), np.array(y).reshape(-1, 1) # O '-1' força o reshape a criar uma coluna.

# Adcionando bias: Para estimar 'b'
X = np.hstack((x, np.ones(x.shape))) # 'hstack' concatena o 'array' criado.

# Extimando a e b:
beta = np.linalg.pinv(X).dot(y) # 'linalg.pinv' cria a matriz pseudo-inversa e multiplica por 'y'
print(f'a estimado: {beta[0][0]}')
print(f'b estimado: {beta[1][0]}')

# Criando o 'plot' com o valor de 'beta' estimado:
plt.figure(figsize=(10,5))
plt.plot(x, y, 'o', label='dados originais')
plt.plot(x, X.dot(beta), label='regressão linear')
plt.legend()
plt.xlabel("x")
plt.ylabel("y")
plt.title("Regressão linear com numpy")
plt.grid()
plt.show()

# Trabalhando com a biblioteca PANDAS (Disponibiliza estruturas de dados rápidas e flexiveis):
import pandas as pd 

# Leitura de dados em csv:
df = pd.read_csv("https://pycourse.s3.amazonaws.com/temperature.csv")
print(f'Data frame carregado csv:\n {df}')

# Leitura de planilhas excel:
# 2 abas (workssheets)

excel_file = pd.ExcelFile("https://pycourse.s3.amazonaws.com/temperature.xlsx") # Carrega o arquivo
df2 = pd.read_excel(excel_file, sheet_name='Sheet1') # Faz a leitura da primeira aba do arquivo, 'sheet_name' especifica a aba que vai ser lida
print(f'Data frame excel:\n {df2}')

# Leitura da 2ª aba, definindo o separador
print("Dados númericos com separador decimal=','")
df3 = pd.read_excel(excel_file, sheet_name='Sheet2', decimal=',') # Definindo o decimal o 'default do panda' vai considerar o '.'
print(f'Definindo o separador decimal:\n {df3}')

# Definindo as primeiras linhas a serem visualizadas:

n_l = 3 # '3' números de linha a mostrar
print(f'Primeiras linhas a visualizar:\n {df.head(n_l)}') # 'head' Retorna o número de linhas definido

# Definindo as ultimas linhas a serem mostradas:
n_l = 3 # '3' números de linhas a mostrar
print(f'Últimas linhas a visualizar:\n {df.tail(n_l)}')

# Verifica o tipo de dado inferido pelo PANDA:
df.dtypes

# Verifica a informação do DataFrame(df):
df.info()

# Verifica o nome das colunas:
df.columns # Pode renomear também o nome das colunas (df.columns = ['col1', 'col2', 'col3'])

# Verificando a estatística dos valores númericos da planilha:
df.describe() # Retorna a estatística da planilha 'df'

# Indexação com PANDAS:

# Seleção de uma coluna:
df['date']

# Acessando multiplos atributos:
df[['date', 'classification']] # Segue a ordem declarada, não do dataframe original

# Acessando os indices com 'iloc(com int)' e 'loc(com str)'

df.iloc[:, 1] # Retorna todos elementos da linha na coluna 1

# Acessando os indices com 'loc':
df.loc[:, 'temperatura']

# Indexação por indice de multiplas colunas:
df.iloc[:, 1:3] # Retorna 'temperatura' e 'classification'

# Indexação por nome de multiplas colunas:
df.loc[:, ['temperatura', 'classification']]

# Indexação Booleana no PANDA:
print(f'Data frame trabalhado:\n {df}')

# Transformando o tipo da coluna date para datetime:
df['date'] = pd.to_datetime(df['date']) # Nesse caso força o 'panda' a considerar date como datetime ao invés de um object
df.dtypes # Mostra o novo tipo do date

# Setando o indice (definindo o indice do df):
df = df.set_index('date')

# Indice setado:
print(df) # Exclui os indice númericos

# Visualizando as 5 primeiras linhas:
df.head()

# Seleção de elementos maior ou igual a 25 graus:
df[df['temperatura'] >= 25]

# Selecionado através da data:
df[df.index <= '2020-03-01']

df.loc[df.index <= '2020-03-01', ['classification']] # Mostra as datas inferior a declarada e a classificação

# Seleção por data do campo classification usando int:
df.iloc[df.index <= '2020-03-01', [-1]] # O '-1' indica o último elemento, nesse caso o 'classification'

# Ordenação com PANDA:

# Ordenação crescente: 
df.sort_values(by='temperatura')

# Ordenação crescente por mais de uma coluna
df.sort_values(by=['classification', 'temperatura'])

# Ordenação decrescente por uma coluna:
df.sort_values(by='temperatura', ascending=False) # 'ascending=False' faz a ordenação decrescente

# Ordenação crescente por indice:
df.sort_index()

# Ordenação decrescente por indice:
df.sort_index(ascending=False)

# Visualização de dados no PANDAS:

df.plot() # Mostra o gráfico de (df)

# Definindo o tamanho das linha do 'plot':
df.plot(figsize=(10, 5), grid=True) # 'figsize' define o tamanho do 'plot'

# Acrescentando Style no 'plot'
df.plot(figsize=(10, 5), style='-o', grid=True); # 'style "-o" vai colocar pontos azuis em cada númeração'

# 'Plot' com 'linewidth' engrossa a linha do gráfico:
df.plot(style='-o', linewidth=2.5, figsize=(10,5), grid=True)

# Colocando cores:
df.plot(style='-o', linewidth=2.5, color="red", figsize=(10,5), grid=True); # 'color=red'define a cor da linha, pode ser usado o hexadecimal.

# Plot de barras:
df['classification'].value_counts().plot.bar(figsize=(10, 5), rot=0) 
#'value_counts() conta a quantidade de elementos, 'rot' define a rotação dos nomes do eixo x, 'plot.bar' significa barra'

# Mais um plot barra:
df.plot(kind='bar', figsize=(10, 5), rot=30) # Nesse exemplo o gráfico será apenas dos valores numericos

from matplotlib.patches import Shadow
# Criando novo plot com 'pie':
df['classification'].value_counts().plot.pie(autopct='%1.1f%%', shadow=True, figsize=(10, 7))
# 'plot.pie' formato do grafico de setores ou 'pizza', 'shadow' sobreamento, 'autopct' coloca a porcentagem
# '%1.1f%%' refere-se ao número de casas decimais desejado, nesse caso 1 após a virgula

# Dataframe a ser trabalhado: 
df.head(6)

# Dicas gerais PANDAS

# Usando o 'groupby' agrupando valores únicos de uma ou mais colunas
df.groupby(by='classification') # Nesse caso agrupamento só por 'classification'

# Após o agrupamento, tirar a média da coluna agrupada:
df.groupby(by='classification').mean() # 'mean' calcula a média da coluna agrupada

# Somando agrupamentos:
df.groupby(by='classification').sum()

# Removendo coluna com 'drop'
df.drop('temperatura', axis=1) # Remove a coluna do eixo 1

df2 = df.copy() # para não alterar a 'df' conforme as alterações de 'df2'

df3 = df2.drop('temperatura', axis=1) # Nesse caso a coluna temperatura não aparecerá printando 'df3'

# Alterando 'df2' sem precisar criar a váriavel 'df3' como foi feito acima, usando 'inplace=True'
df2.drop('temperatura', axis=1, inplace=True)

df2.head() # alterada pelo comando anterior

df.head() # Continua sem alterações

# Aprendizado de Máquina:
# Classificação com scikit-learn
df.head()

# Exraindo as variáveis x, y:
x, y = df[['temperatura']].values, df[['classification']].values # 'x' recebe os valores temperatura, 'y' classification.
print(f'Valor de x:\n {x}')
print(f'Valor de y:\n {y}')

# Fazendo pré-processamento:
from sklearn.preprocessing import LabelEncoder # Para codificar as str em int dos dados 'classification'

# Convertendo 'y' em valores númericos:
le = LabelEncoder() #'le' lebel enconder instaciado por ser uma classe
y = le.fit_transform(y.ravel())  # 'fit_transform' Verifica e transforma as duas coisas ao mesmo tempo.
print(f'Valor de y codificado: {y}')

# Importando o modelo:
from sklearn.linear_model import LogisticRegression

# Classificador com o modelo da regressão logistica:
clf = LogisticRegression() # 'cfl(class file)' Instanciado por ser uma classe
clf.fit(x, y) # O 'fit' vai buscar os melhores parametros que classifiquem melhor os dados

# Gerando 100 valores de temperatura
# Lineramente espaçados entre 0 e 45
# Predição em novos valores de temperatura
x_test = np.linspace(start=0., stop=45., num=100).reshape(-1, 1)

# Predição desse valores:
y_pred = clf.predict(x_test)
print(f'Valores preditos:\n {y_pred}')

# Convertendo o 'y_pred' para os valores originais:
y_pred = le.inverse_transform(y_pred) # 'le' foi a variável instanciada para o 'LabelEncoder'
print(f'Valores y_pred convertidos aos originais:\n {y_pred}')

# Criando um 'output' do novo modelo criado:
output = {'new_temp': x_test.ravel(),
          'new_class': y_pred.ravel()}
output = pd.DataFrame(output) # Cria uma nova tabela com os novos dados

output.tail() # Retorna as ultimas 5 linhas do DataFrame

output.head() # Retorna as primeiras 5 linhas do DataFrame

print(output)

# Criando um 'plot' de caixas(box plot):
output.boxplot(by='new_class', figsize=(10, 5))

# Criando sistema com scikit_learn:
def classify_temp():
  ask = True
  while ask:
    # Recebe os dados do usuário:
    temp = input('Insira a temperatura (graus Celsius: ')

    # Transformando os dados recebidos para numpy array
    temp = np.array(float(temp)).reshape(-1, 1)

    # Classificando os dados:
    class_temp = clf.predict(temp)

    # Convertendo para os valores originais(str):
    class_temp = le.inverse_transform(class_temp)

    # Resultados:
    print(f'A classificação da temperatura {temp.ravel()[0]} é:', class_temp[0])

    # Opção de continuar ou não:
    ask = input('Nova classificação (y/n') == 'y'

# Chamando a função do sistema:
classify_temp()

# Regressão linear com 'scikit-learn':
# Dados:
x = [-1., -0.77777778, -0.55555556, -0.33333333, -0.11111111,
      0.11111111, 0.33333333, 0.55555556, 0.77777778, 1.]
y = [-1.13956201, -0.57177999, -0.21697033, 0.5425699, 0.49406657,
     1.14972239, 1.64228553, 2.1749824, 2.64773614, 2.95684202]

# Plot dos dados:
plt.figure(figsize=(10,5)) # Define o tamanho da figura
plt.plot(x, y, 'o', label='dados originais') # Faz o 'plot' o 'o' define o grafico com bolinhas.
plt.legend() # Expõe o label dados originais
plt.xlabel("x") # Define os nomes dos eixos
plt.ylabel("y")
plt.grid() # quadricular a figura
plt.show()

# Transformando os dados em 'numpy array':
x, y = np.array(x).reshape(-1, 1), np.array(y).reshape(-1, 1)

# Criando o modelo:
from sklearn.linear_model import LinearRegression

# Treinando o modelo: y = a*x + b, valores reais (a, b) =(2, 1)
reg = LinearRegression() # Instanciando
reg.fit(x, y)

# Colhendo os resultados:
# Valores estimados usando o numpay diretamente
# a estimado em numpy: 2.05414951
# b estimado em numpy: 0.96798926
print(f'a estimado no modelo sklearn: {reg.coef_.ravel()[0]}') # 'coef' lista de coeficientes lineares, '.revel()' coloca o array como unidimensional
print(f'b estimado no modelo sklearn: {reg.intercept_[0]}') # 'intercept' refere-se ao termo nesse caso sempre o 'b'

# Criando predições do modelo:
y_pred = reg.predict(x)

# Avaliando o quão bom ou quão ruim é o modelo, utlizando 'score':
score = reg.score(x, y)
print(f'O score: {score}') # O score quanto mais próximo de '1' melhor é.

# Plot dos dados com score:
plt.figure(figsize=(10,5)) # Define o tamanho da figura
plt.plot(x, y, 'o', label='dados originais') # Faz o 'plot' o 'o' define o grafico com bolinhas.
plt.plot(x, y_pred, label='regressão linear (R2:{:.3f})'.format(score))
plt.legend() # Expõe o label dados originais
plt.xlabel("x") # Define os nomes dos eixos
plt.ylabel("y")
plt.title('Regressão linear no scikit-learn')
plt.grid() # quadricular a figura
plt.show()

# Plot dos dados com score e R2:
plt.figure(figsize=(10,5)) # Define o tamanho da figura
plt.plot(x, y, 'o', label='dados originais') # Faz o 'plot' o 'o' define o grafico com bolinhas.
plt.plot(x, y_pred, label='regressão linear (R2:{:.3f})'.format(score))
plt.hlines(y=y.mean(), xmin=x.min(), xmax=x.max(), linestyle='dashed', label='Modelo de referencia do R2') # Coloca uma linha horizontal(a média)
plt.legend() # Expõe o label dados originais
plt.xlabel("x") # Define os nomes dos eixos
plt.ylabel("y")
plt.title('Regressão linear no scikit-learn')
plt.grid() # quadricular a figura
plt.show()

# Criando função para calculo do MSE(MÉDIA):
def mse(y_true, y_pred, is_ref = False):
  # mse modelo:
  if is_ref:
    mse = ((y_true - y_true.mean()) ** 2).mean()
  else:
    mse = ((y_true - y_pred) ** 2).mean()
  return mse

# Função para calculo do coeficiente de determinação R2
def r2(mse_reg, mse_ref):
  return 1 - mse_reg/mse_ref

# Resultado de 'y' e 'y_pred':
print(f'Valor do y_true: {y.ravel()}')
print(f'Valor do y_pred: {y_pred.ravel()}')

# Calculando o mse do modelo:
mse_reg = mse(y_true=y, y_pred=y_pred)
print(f'O MSE do modelo de regressão é: {mse_reg}')
mse_ref = mse(y_true=y, y_pred=y_pred, is_ref=True)
print(f'O MSE do modelo de referência é: {mse_ref}')

# Calculando o R2 score do modelo:
r2_score = r2(mse_reg=mse_reg, mse_ref=mse_ref)
print(f'Coeficiente R2 do modelo: {r2_score}')

# Todos os calculos acima para calcular o R2 e MSE, poderia ser resumido em:
r2_score_skl = reg.score(x, y)
print(f'Coeficiente R2 do modelo implementado (scikit-learn): {r2_score_skl}') # Retornaria o mesmo valor de 'r2_score'